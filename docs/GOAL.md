# GA-Life

Cellular Automata for Visualization of Genetic Algorithms (Conway-aligned)

---

## 1. 프로젝트의 개요

#### 1.1. 이름 및 슬로건

-   **이름**: “GA-Life - Visualization of Genetic Algorithms”
-   **슬로건**: “Cellular Automata for Visualization of Genetic Algorithms (Conway-aligned)”

#### 1.2. 개발 목적 및 규칙 설명

-   **개발 목적**
    유전 알고리즘은 실제 생물의 진화를 모방해서 문제를 해결하는 최적화 기법의 일종이다. 유전 알고리즘은 CNN 등 인공 신경망이 인공지능의 대세가 된 지금도 인공 신경망의 초기화에 쓰이는 등 다양한 활용성을 지니고 있다. 하지만 서적 등의 예제에서 유전 알고리즘을 시각적으로 설명하는 잘 보이지 않는데, GA-Life는 세포 자동자의 각 세포에 유전 알고리즘을 적용하여 공간적으로 세포들이 진화하는 모습을 보여줌으로써 유전 알고리즘의 시각화가 가능하다고 사료된다. 또한 더 나아가 간략한 진화 시뮬레이션 모델로의 확장도 가능하다.

-   **기본 원칙**
    보드는 2D 직사각형 격자로 채워져 있으며, 경계는 토러스 경계로 한다. 칸은 크게 세포가 살아있는 칸과 죽어있는 칸으로 구분 가능하며 이 칸이 한 번 동기 업데이트 되는 걸 한 세대가 지나갔다고 표현한다. 모든 살아있는 세포는 본인 주변 8개의 칸에 영향력을 끼치는데, 이 영향력에 따라 다음 세대에서 칸이 세포가 살아있는 칸이 될지 죽어있는 칸이 될지의 여부가 결정된다. 영향력은 소수점 둘째 자리에서 반올림한다.

    칸에 미치는 영향력이 너무 많은 경우도, 너무 적은 경우도 생존/탄생에 불리하게 설계를 하는 것이 GA-Life의 목적 중 하나이며, 그렇기에 기본적으로 유전자간 우위는 존재하지 않는다. 다만 칸의 지형 및 환경은 위치 별로 다르게 생존에 유리한 유전자가 생기도록 만들 수 있는 요소이다.

-   **유전자와 영향력**
    모든 세포는 유전자를 가지고 있으며, 살아있는 세포가 주변 8칸에 미치는 영향력의 크기는 그 세포가 탄생할 때 정해지는 유전자에 따라 달라진다. 각각의 세포는 유전자 `[U,D,L,R] ∈ {2,4,6,8,10}`을 가지고 있으며, 각각의 값은 상/하/좌/우에 해당 값만큼의 영향력을 준다는 것을 의미한다. 여기서 대각선은 `(관련된 두 값 평균 - 1)`로 계산 가능한데, 예를들어 `[10, 4, 6, 8]`의 유전자를 가진 세포는 왼쪽 위의 칸에 7만큼의 영향력을 행사한다. 예시를 전부 나타내면 다음과 같다.

    <예시 - 영향력>
    ```
    [[7, 10, 8],
     [6,  X, 8],
     [4,  4, 5]]
    ```
    이런 규칙을 따르는 만큼 주변 살아있는 세포가 주는 영향력의 총합인 `S_total`은 지형 등 다른 보정 없이는 최대 76이다.

#### 1.3. 기존 연구와의 차별점

GA-Life는 기존 인공 생명 프로젝트들과 다음과 같은 차별점을 통해 '공간적 유전 알고리즘 동역학' 관찰이라는 고유한 목표에 집중합니다.

1.  **내재적 적합도(Intrinsic Fitness)**: Avida와 달리, 외부 과제 해결이 아닌 시스템의 물리 법칙(생존/탄생 확률) 안에서 '생존과 번식' 자체가 유일한 목표가 됩니다. 이는 순수한 진화 압력이 만들어내는 패턴을 관찰하는 데 최적화되어 있습니다.

2.  **내장된 국소적 진화(Built-in & Local Evolution)**: Lenia의 외부 루프 진화와 달리, GA-Life는 세포가 탄생하는 모든 위치에서 '선택-교차-변이'가 일어나는, 진화 자체가 핵심 규칙으로 내장된 모델입니다.

3.  **확률론적 규칙(Probabilistic Rules)**: 콘웨이의 생명 게임의 결정론적 규칙을 넘어, 연속적인 확률 모델을 사용함으로써 더 다채롭고 예측 불가능한 유기적 패턴의 발현을 목표로 합니다.

---

## 2. 생존/죽음 및 탄생/미탄생 판정

#### 2.1. 기본 규칙

-   **생존/사망 및 탄생/미탄생의 정의**
    -   **생존**: 현 세대의 살아있는 칸이 다음 세대에도 살아있는 칸으로 유지되는 경우.
    -   **사망**: 현 세대의 살아있는 칸이 다음 세대에는 죽어있는 칸으로 변하는 경우.
    -   **탄생**: 현 세대의 죽어있는 칸이 다음 세대에는 살아있는 칸으로 변하는 경우.
    -   **미탄생**: 현 세대의 죽어있는 칸이 다음 세대에도 죽어있는 칸으로 유지되는 경우.

    초기화 시, 별도 설정을 하지 않는 이상 세포 밀도 `ρ = 0.25`로 생성된다.

-   **연속 확률 모델**
    로지스틱 함수 `σ(x)=1/(1+e^(-x))`를 기반으로, 해당 칸이 받는 총 영향력(`S_total`)에 따라 생존/탄생 확률이 연속적으로 결정된다.

    <수식 - p_live: 생존 확률, p_born: 탄생 확률>
    ```math
    \begin{aligned}
    &p_{live}(S_{total}) = \text{clip}(\alpha \cdot \{\sigma(\beta \cdot (S_{total} - \mu))\} \cdot \{1 - \sigma(\beta \cdot (S_{total} - \mu))\}^\gamma + \delta, 0, 1) \\
    &p_{dead}(S_{total}) = 1 - p_{live}(S_{total}) \\
    &p_{born}(S_{total}) = \text{clip}(\alpha \cdot \{\sigma(\beta \cdot (S_{total} - \nu))\} \cdot \{1 - \sigma(\beta \cdot (S_{total} - \nu))\}^\gamma + \delta, 0, 1) \\
    &p_{unborn}(S_{total}) = 1 - p_{born}(S_{total})
    \end{aligned}
    ```

-   **위 수식에서의 기본값**
    ```math
    \alpha = 4 \quad \beta = -0.3 \quad \gamma = 1 \quad \mu = 27.0 \quad \nu = 34.5 \quad \delta = -0.01
    ```

-   **연속 확률 모델의 예외 사항**
    -   계산된 확률값이 `ε` (기본값 0.003)보다 작을 경우 0으로 처리한다.
    -   탄생은 주변 8칸에 살아있는 세포(또는 '항상 생존' 환경)가 1개 이상 존재해야만 가능하다.

#### 2.2. 지형 및 환경

-   **기본 설명**: 지형과 환경은 모두 칸에 종속된다. 지형은 불변의 속성이지만, 환경은 조건에 따라 변할 수 있다. 이 구분은 '지형'의 효과를 시뮬레이션 시작 시 미리 계산해두는 최적화를 가능하게 한다.

-   **지형 (Terrain)**
    1.  **높낮이 지형**: 주변 칸과의 높이 차에 따라 영향력이 보정된다.
    2.  **영향력 2배 지형**: 해당 칸의 세포가 전파하는 영향력을 2배로 증폭시킨다.
    3.  **영향력 1/2배 지형**: 해당 칸의 세포가 전파하는 영향력을 1/2배로 감소시킨다.

-   **환경 (Environment)**
    1.  **항상 생존 환경**: 해당 칸은 항상 살아있는 상태로 판정된다.
    2.  **항상 사망 환경**: 해당 칸은 항상 죽어있는 상태로 판정된다.
    3.  **강제 변이 환경**: 해당 칸에서 세포 탄생 시 100% 확률로 변이가 발생한다.
    4.  **추가 자원 환경**: 확률 수식의 `δ` 값을 0.1만큼 올려 생존/탄생에 유리하게 만든다.
    5.  **노이즈 환경**: `δ` 값을 -0.05 ~ 0.05 사이에서 무작위로 변화시킨다.

---

## 3. 유전 알고리즘

#### 3.1. 초기화 (상호 배타적)
-   **정규분포 기반 확률 초기화 (기본값)**: 평균 6, σ≈2 정규분포에 따라 유전자를 생성한다.
-   **동일 확률 초기화**: 모든 유전자가 동일한 확률로 나타난다.
-   **극단 확률 강화 초기화**: 양 극단값(2, 10)의 등장 확률을 높인다.
-   **모두 [6, 6, 6, 6] 초기화**: 모든 세포의 유전자를 `[6, 6, 6, 6]`으로 통일한다.

#### 3.2. 부모 선택
-   **후보 선정**: 새로운 세포가 탄생할 칸의 주변 8칸에 있는 살아있는 세포들이 부모 후보다.
-   **적합도 계산**: 각 후보의 생존 확률(`p_live`)을 적합도로 사용하여, 적합도가 높을수록 부모로 선택될 확률이 높아진다.

#### 3.3. 교차 (상호 배타적)
-   **부모 동일 확률 50/50 (기본값)**: 유전자의 각 좌위(U, D, L, R)를 50% 확률로 양 부모에게서 물려받는다.
-   **24칸 다수결**: 주변 24칸의 유전자 분포를 고려하여, 더 흔한 유전자를 물려받을 확률을 높인다.

#### 3.4. 변이 (상호 배타적)
-   **부분 변이 (기본값)**: 각 유전자 좌위에 대해 개별적으로 변이 확률(`p_mut`, 기본값 0.02)을 적용한다.
-   **전체 변이**: 변이가 발생하면 4개의 유전자 전체를 균등 확률로 다시 선택한다.

#### 3.5. 한 틱 파이프라인 (Detailed)
한 세대(tick)가 진행되는 과정은 다음과 같은 명확한 단계로 구성되며, 이는 다음 세대의 상태가 현재 세대에만 의존하도록 보장합니다 (동기 업데이트).

1.  **이웃 영향 합산 (Influence Aggregation)**
    -   전체 격자 크기와 동일한 `influence_grid`를 0으로 초기화합니다.
    -   현재 세대의 격자를 순회하며 살아있는 모든 세포를 찾습니다.
    -   각 살아있는 세포에 대해, 자신의 유전자와 지형 효과를 바탕으로 주변 8칸에 전파할 영향력을 계산하고, 이 값을 `influence_grid`의 해당 칸에 더해줍니다.

2.  **판정 및 자손 생성 (Judgment & Reproduction)**
    -   다음 세대의 상태를 저장할 `next_generation_grid`를 준비합니다.
    -   현재 격자의 모든 칸(0,0부터)을 순회합니다.
        -   해당 칸의 `influence_grid` 값(`S_total`)과 환경 효과를 종합합니다.
        -   현재 칸이 살아있으면 `p_live` 공식으로 생존 여부를, 죽어있으면 `p_born` 공식으로 탄생 여부를 확률적으로 판정합니다.
        -   판정 결과를 `next_generation_grid`에 기록합니다.
        -   **(탄생 시)**: 세포 탄생이 결정되면, `3.2 ~ 3.4`의 유전 알고리즘(부모 선택, 교차, 변이)을 수행하여 자손의 유전자를 결정하고 `next_generation_grid`에 함께 저장합니다.

3.  **동기 커밋 (Synchronous Commit)**
    -   모든 칸에 대한 판정이 끝나면, 현재 세대 격자를 `next_generation_grid`로 완전히 교체합니다.
    -   이로써 한 세대의 업데이트가 완료됩니다.

---

## 4. 기술 스택 및 아키텍처

본 프로젝트는 웹 환경에서 높은 성능의 시뮬레이션과 상호작용이 가능한 UI를 구현하기 위해 다음과 같은 기술 스택과 아키텍처를 채택합니다.

#### 4.1. 기술 스택 (Technology Stack)

-   **Core Engine**: **Rust / WebAssembly (WASM)**
    -   세포 자동자, 유전 알고리즘 등 모든 무거운 연산을 담당합니다. Rust의 높은 성능과 메모리 안전성을 통해 C/C++에 버금가는 속도를 웹에서 구현합니다.
-   **Frontend Framework**: **React (with TypeScript)**
    -   UI 컴포넌트, 상태 관리, 사용자 상호작용을 담당합니다. TypeScript를 통해 코드의 안정성과 유지보수성을 높입니다.
-   **Rendering**: **HTML5 Canvas**
    -   수천 개의 세포를 효율적으로 화면에 그리기 위한 렌더링 계층입니다.

#### 4.2. 아키텍처 (Architecture)

성능과 관심사의 분리를 위해 3-Layer 아키텍처를 사용합니다.

1.  **Core Layer (Rust/WASM)**: 순수한 시뮬레이션 로직만 포함하는 엔진입니다. 외부 세계(웹)에 대한 의존성이 없습니다.
2.  **Bridge Layer (TypeScript)**: React 애플리케이션과 WASM 엔진 사이를 잇는 다리입니다. WASM 모듈을 로드하고, 데이터와 이벤트를 양방향으로 변환 및 전달합니다.
3.  **View Layer (React/Canvas)**: 사용자에게 보여지는 모든 UI와 시뮬레이션 화면을 담당합니다.

#### 4.3. 렌더링 파이프라인 (Rendering Pipeline)

매끄러운 애니메이션을 위해 `requestAnimationFrame`을 사용한 렌더링 루프를 구성하며, 성능 최적화를 위해 다음의 파이프라인을 따릅니다.

1.  **JS**: `requestAnimationFrame` 루프 내에서 WASM 엔진의 `tick()` 함수를 호출하여 시뮬레이션을 한 세대 진행시킵니다.
2.  **JS -> Rust**: `tick()` 함수가 Rust 내부에서 실행됩니다.
3.  **Rust -> JS**: 시뮬레이션이 끝난 후, JS는 Rust로부터 세포 데이터 전체를 **복사하는 대신**, 데이터가 저장된 **WASM 메모리의 포인터(pointer)를 전달받습니다.**
4.  **JS**: 전달받은 포인터를 이용해 WASM의 메모리를 직접 읽는 `TypedArray`를 생성합니다.
5.  **Canvas**: 이 `TypedArray`를 순회하며 각 세포의 상태를 읽어와 `Canvas`에 빠르게 렌더링합니다. 이 방식은 JS와 WASM 간의 데이터 전송 비용을 '0'에 가깝게 만들어줍니다.

---

## 5. UI/UX

#### 5.1. 기본 화면 구성
-   메인 실행 화면
-   파라미터/지형 에디터

#### 5.2. 볼 수 있는 레이아웃
-   유전자 맵 (각 유전자를 색상으로 표현)
-   지형 & 환경 맵
-   확률 맵 (각 칸의 생존/탄생 확률을 시각화)

#### 5.3. 통계
-   세포가 살아있는 칸의 밀도
-   세대별 탄생/사망 이벤트 수
-   세포의 평균 수명

---

## 6. 기타 기능

-   **시드 고정**: 동일한 시뮬레이션을 재현할 수 있도록 랜덤 시드를 고정하는 기능.
-   **파라미터 개별 설정**: UI를 통해 모든 파라미터를 실시간으로 조작.
-   **설정 저장/불러오기**: 재현성을 위해 시드와 모든 파라미터 설정을 JSON 파일로 저장하고 불러오는 기능.

---

## 7. 마무리

#### 7.1. 최종 목표 및 마일스톤

이 프로젝트의 최종 성공은 **"단일한 최강의 유전자(Dominant Strategy)는 존재하지 않으며, 최적의 유전자는 주어진 환경(지형 등)에 따라 달라진다"** 는 것을 명확하게 보여주는 것입니다. 이는 규칙 기반으로 최적화하기 힘든 문제에 유전 알고리즘을 사용하는 근본적인 이유를 시각적으로 증명하는 과정입니다.

이를 증명하기 위해, 최소 두 개 이상의 서로 다른 환경 시나리오에서 각각 다른 유전자 그룹이 번성하는 것을 통계적으로 확인하는 것을 목표로 합니다.

-   **예시 시나리오 A**: '산악 지형'에서는 상(U) 유전자값이 높은 그룹이 생존율 우위를 보임.
-   **예시 시나리오 B**: '평야 지형'에서는 좌(L)/우(R) 유전자값이 높은 그룹이 생존율 우위를 보임.

##### 기반 현상 (Foundational Phenomena)

위 최상위 목표를 달성하고 관찰하기 위해, 시스템이 먼저 다음과 같은 기본적인 현상들을 안정적으로 보여줄 수 있어야 합니다.

1.  **안정성 (Stability)**: 시스템이 생명을 유지할 수 있는 기본적인 능력을 갖추었는가?
2.  **이동성 (Mobility)**: 국소적 규칙이 거시적인 움직임을 만들어내는가?
3.  **주기성 (Periodicity)**: 시스템 내에 동적인 평형 상태가 나타나는가?

#### 7.2. 추가하면 좋을 점

-   사용자 편의를 위해, 민감도 파라미터 `β`를 직접 입력하는 대신 "원하는 반치폭(FWHM)"을 입력하면 내부적으로 `β`를 역산하여 적용하는 기능.